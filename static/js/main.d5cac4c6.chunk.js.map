{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["iCalDateParser","require","calendars","setData","a","promises","map","calendar","text","fetch","url","response","id","success","Promise","all","newData","App","useState","json","localStorage","getItem","Error","JSON","parse","getCalendarInLocalStorage","filter","_error","uuid","enabled","setCalendars","data","dateFns","Date","start","end","setCalendarsInLocalStorage","stringify","setItem","calendarsElement","index","lastRow","length","deleteElement","onClick","newCalendars","slice","key","Input","type","defaultChecked","onChange","e","target","checked","required","defaultValue","placeholder","push","value","useEffect","fetchCalendars","startsWith","veventsAll","ical","ical2json","convert","VCALENDAR","vevent","now","cols","day","endOfDay","vevents","DTSTART","DTEND","format","events","Card","UID","CardBody","CardTitle","SUMMARY","CardSubtitle","Col","getTime","className","Container","Row","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d5cac4c6.chunk.js","sourcesContent":["import React, { useState, ChangeEvent, useEffect } from 'react';\nimport { Input, Container, Col, Row, Card, CardTitle, CardSubtitle, CardBody } from 'reactstrap';\nimport uuid from \"uuid/v4\";\nimport * as dateFns from 'date-fns';\n// @ts-ignore\nimport ical2json from 'ical2json';\nconst iCalDateParser = require('ical-date-parser');\n\n\ninterface Calendar {\n  id: string,\n  enabled: boolean,\n  url: string,\n}\n\ninterface iCalData {\n  id: string,\n  url: string,\n  success: boolean,\n  text: string | null,\n}\n\ninterface VEVENT {\n  CREATED: string,\n  DESCRIPTION: string,\n  DTEND: string,\n  DTSTART: string,\n  DTSTAMP: string,\n  SEQUENCE: string,\n  SUMMARY: string,\n  UID: string,\n}\n\nfunction getCalendarInLocalStorage(): Calendar[] {\n  const json = localStorage.getItem('calendars');\n  if (!json) {\n    throw new Error(`Does not exist`);\n  }\n\n  return JSON.parse(json);\n}\n\nconst END = 3;\n\nasync function fetchCalendars(calendars: Calendar[], setData: (newData: iCalData[]) => void): Promise<void> {\n  const promises = calendars.map(async (calendar) => {\n    let text = null;\n\n    try {\n      const response = await fetch(calendar.url);\n      text = await response.text();\n    } catch (error) {\n\n    }\n\n    return {\n      id: calendar.id,\n      url: calendar.url,\n      success: text !== null,\n      text,\n    };\n  })\n\n  const newData = await Promise.all(promises);\n  setData(newData);\n}\n\nconst App: React.FC = () => {\n  const [calendars, setCalendars] = useState<Calendar[]>(() => {\n    try {\n      return getCalendarInLocalStorage()\n        .filter(calendar => calendar !== null);\n    } catch (_error) {\n      // console.error(_error);\n    }\n    return [\n      {\n        id: uuid(),\n        enabled: false,\n        url: '',\n      }\n    ];\n  });\n\n  const [data, setData] = useState<iCalData[]>([]);\n  const [start, setStart] = useState(dateFns.startOfDay(new Date()));\n  const [end, setEnd] = useState(dateFns.endOfDay(dateFns.addDays(start, END)));\n\n  function setCalendarsInLocalStorage(calendars: Calendar[]): void {\n    const json = JSON.stringify(calendars);\n    localStorage.setItem('calendars', json);\n    setCalendars(calendars);\n  }\n\n  const calendarsElement = calendars.map((calendar, index) => {\n    const lastRow = index === calendars.length - 1;\n    let deleteElement = null;\n\n    const onChange = (e: ChangeEvent<HTMLInputElement>): void => {\n      const newCalendars = calendars.slice(0);\n      if (lastRow) {\n        newCalendars.push({\n          id: uuid(),\n          enabled: false,\n          url: '',\n        });\n      } else {\n        newCalendars[index].url = e.target.value;\n      }\n      // setCalendars(newCalendars);\n      setCalendarsInLocalStorage(newCalendars);\n    };\n\n    if (!lastRow) {\n      const onClickToDelete = (): void => {\n        const newCalendars = calendars.slice(0);\n        delete newCalendars[index];\n        // setCalendars(newCalendars);\n        setCalendarsInLocalStorage(newCalendars);\n      };\n\n      deleteElement = <span onClick={onClickToDelete}>Delete</span>;\n    }\n\n    return (\n      <tr key={calendar.id}>\n        <td>\n          <Input\n            type=\"checkbox\"\n            defaultChecked={calendar.enabled}\n            onChange={(e) => {\n              const newCalendars = calendars.slice(0);\n              newCalendars[index].enabled = e.target.checked;\n              setCalendarsInLocalStorage(newCalendars);\n            }}\n          />\n        </td>\n        <td>\n          <Input\n            required={!lastRow}\n            key={calendar.id}\n            type=\"url\"\n            defaultValue={calendar.url}\n            placeholder=\"https://\"\n            onChange={(e) => onChange(e)}\n          />\n        </td>\n        <td>\n          {deleteElement}\n        </td>\n      </tr>\n    )\n  });\n\n  useEffect(() => {\n    const validCalendars = calendars.filter((calendar) =>\n      calendar.enabled === true && calendar.url.startsWith(\"http\")\n    )\n\n    fetchCalendars(validCalendars, setData);\n  }, [calendars])\n\n  const veventsAll: { calendar: string, vevent: VEVENT}[] = [];\n\n  data\n    .filter(ical => ical.success)\n    .map(ical => {\n    const json = ical2json.convert(ical.text);\n    veventsAll.push(...json.VCALENDAR[0]['VEVENT'].map((vevent: VEVENT) => {\n      return {\n        calendar: ical.id,\n        vevent,\n      }\n    }))\n  })\n\n  let now = start;\n\n  // let veventsByDay: { day: Date, vevents: VEVENT[] }[] = [];\n  let cols = [];\n\n  while (now.getTime() < end.getTime()) {\n    let day = new Date(now);\n    let endOfDay = dateFns.endOfDay(now);\n\n    // TODO: doesn't handle repeat\n    const vevents = veventsAll.filter(({vevent}) => \n      dateFns.areIntervalsOverlapping(\n        { start: day, end: endOfDay },\n        { start: iCalDateParser(vevent.DTSTART), end: iCalDateParser(vevent.DTEND) },\n      )\n    ).map(({vevent}) => vevent);\n\n    const format = dateFns.format(day, 'yyyy-MM-dd');\n\n    const events = vevents.map((vevent) => {\n      const start = iCalDateParser(vevent.DTSTART);\n      const end = iCalDateParser(vevent.DTEND);\n\n      return (\n        <Card key={`${format}:${vevent.UID}`}>\n          <CardBody>\n            <CardTitle>\n              {vevent.SUMMARY}\n            </CardTitle>\n            <CardSubtitle>\n              {dateFns.format(start, 'HH:mm')} -\n              {dateFns.format(end, 'HH:mm')}\n            </CardSubtitle>\n          </CardBody>\n        </Card>\n      )\n    });\n\n    cols.push(\n      <Col key={format}>\n        <div>{format}</div>\n        {events}\n      </Col>\n    );\n\n    // veventsByDay.push({\n    //   day,\n    //   vevents,\n    // })\n\n    now = dateFns.addDays(now, 1);\n  }\n\n  return (\n    <div className=\"App\">\n      <Container>\n        <table className=\"table\">\n          <tbody>\n            {calendarsElement}\n          </tbody>\n        </table>\n      </Container>\n      <Row>\n        {cols}\n      </Row>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}